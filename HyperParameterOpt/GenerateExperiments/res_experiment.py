import networkx as nx
import numpy as np
import pickle
from math import floor
from rescomp import ResComp, specialize, lorenz_equ
from scipy import sparse

TOL = 5

#-- Network topologies --#
    
def barab1():
    """ Barabasi-Albert preferential attachment. Each node is added with one edge
    """
    n = np.random.randint(2000,3500)
    m = 1
    A = nx.adj_matrix(nx.barabasi_albert_graph(n,m)).T
    return sparse.dok_matrix(A)
    
def barab2():
    """ Barabasi-Albert preferential attachment. Each node is added with two edges
    """
    n = np.random.randint(2000,3500)
    m = 2
    A = nx.adj_matrix(nx.barabasi_albert_graph(n,m)).T
    return sparse.dok_matrix(A)

def erdos():
    """ Erdos-Renyi random graph. p=2/n
    """
    n = np.random.randint(2000,3500)
    p = 2/n
    A = nx.adj_matrix(nx.erdos_renyi_graph(n,p)).T
    return sparse.dok_matrix(A)
    
def random_digraph():
    """ Random digraph. Each directed edge is present with probability p=2/n
    """
    n = np.random.randint(2000,3500)
    p = 2/n
    return sparse.random(n,n, density=p, data_rvs=np.ones, format='dok')

def watts():
    """ Watts-Strogatz small world model
    """
    n = np.random.randint(2000,3500)
    k = 5
    p = .05
    A = nx.adj_matrix(nx.watts_strogatz_graph(n,k,p)).T
    return sparse.dok_matrix(A)

def remove_edges(A,nedges):
    """ Randomly removes 'nedges' edges from a sparse matrix 'A'
    """
    A.todok()
    # Remove Edges
    keys = list(A.keys())
    remove_idx = np.random.choice(range(len(keys)),size=nedges, replace=False)
    remove = [keys[i] for i in remove_idx]
    for e in remove:
        A[e] = 0
    return A

#-- Differential equation utilities --#

def random_lorenz_x0():
    """ Random initial condition for lorenz equations """
    return  20*(2*np.random.rand(3) - 1)

def rc_solve_ode(diff_eq_params):
    """ Wrapper for solving arbitrary ODEs"""
    solver = diff_eq_params.pop("solver")
    sol = solver(**diff_eq_params)
    diff_eq_params["solver"] = solver
    return sol

def how_long_accurate(u, pre, tol=1):
    """ Find the first i such that ||u_i - pre_i||_2 > tol """
    for i in range(u.shape[1]):
        dist = np.sum((u[:,i] - pre[:,i])**2)**.5
        if dist > tol:
            return i
    return u.shape[1]

#-- Main experiment --#

def experiment(fname, network_generator, 
             res_params, diff_eq_params,
             ntrials=1000,  norbits=5, 
             x0=random_lorenz_x0, remove_p=0
            ):
    """ Tests the reservoir computers generated by the given hyper parameters 
        on 'norbits' different orbits
    """
    
    # Make dictionary to store data
    results = {i:{'net':None, 'pred':[], 'err':[]} for i in range(ntrials)}

    i = 0
    while i < ntrials:
        net = network_generator()
        # Remove Edges
        if remove_p != 0:
            net = remove_edges(net, floor(remove_p*np.sum(net != 0)))
        results[i]["net"] = net
        
        
        for j in range(norbits):

            # Initial condition
            diff_eq_params["x0"] = x0()
            train_t, test_t, u = rc_solve_ode(diff_eq_params)
            rc = ResComp(net, **res_params)

            # Train network
            results[i]["err"].append(rc.fit(train_t, u))
            results[i]["pred"].append(how_long_accurate(u(test_t), rc.predict(test_t), tol=TOL))

        i += 1
        pickle.dump(results, open(fname,"wb"))
        print(f"Net complete-- \n\tNet: {network_generator} \n\tPercent {remove_p}")
