import networkx as nx
import numpy as np
import pickle
from math import floor
from rescomp import ResComp, specialize, lorenz_equ
from scipy import sparse

#-------------------------------------
# Constant for measuring preformance
# Do not change
TOL = 5
#-------------------------------------

#-- Network topologies --#

def barab1():
    """ Barabasi-Albert preferential attachment. Each node is added with one edge
    """
    n = np.random.randint(2000,3500)
    m = 1
    A = nx.adj_matrix(nx.barabasi_albert_graph(n,m)).T
    return sparse.dok_matrix(A)

def barab2():
    """ Barabasi-Albert preferential attachment. Each node is added with two edges
    """
    n = np.random.randint(2000,3500)
    m = 2
    A = nx.adj_matrix(nx.barabasi_albert_graph(n,m)).T
    return sparse.dok_matrix(A)

def erdos(mean_degree):
    """ Erdos-Renyi random graph. p=2/n
    """
    n = np.random.randint(2000,3500)
    p = mean_degree/n
    A = nx.adj_matrix(nx.erdos_renyi_graph(n,p)).T
    return sparse.dok_matrix(A)

def random_digraph(mean_degree):
    """ Random digraph. Each directed edge is present with probability p=2/n
    """
    n = np.random.randint(2000,3500)
    p = mean_degree/n
    return sparse.random(n,n, density=p, data_rvs=np.ones, format='dok')

def watts3(p):
    """ Watts-Strogatz small world model
    """
    n = np.random.randint(2000,3500)
    k = 3
    A = nx.adj_matrix(nx.watts_strogatz_graph(n,k,p)).T
    return sparse.dok_matrix(A)

def watts5(p):
    """ Watts-Strogatz small world model
    """
    n = np.random.randint(2000,3500)
    k = 5
    A = nx.adj_matrix(nx.watts_strogatz_graph(n,k,p)).T
    return sparse.dok_matrix(A)

def remove_edges(A,nedges):
    """ Randomly removes 'nedges' edges from a sparse matrix 'A'
    """
    A.todok()
    # Remove Edges
    keys = list(A.keys())
    remove_idx = np.random.choice(range(len(keys)),size=nedges, replace=False)
    remove = [keys[i] for i in remove_idx]
    for e in remove:
        A[e] = 0
    return A

def generate_adj(network, param):
    """ Generate a network with the supplied topology

        Parameters
        ----------
        network (str) : one of [barab1, barab2, erdos, random_digraph, watts]

        Returns
        -------
        net (sparse matrix) : An adjacency matrix with the specified network topology
    """
    network_options = ['barab1', 'barab2', 'erdos', 'random_digraph', 'watts3', 'watts5']
    if network not in network_options:
        raise ValueError('{network} not in {network_options}')
    if network == 'barab1':
        net = barab1()
    if network == 'barab2':
        net = barab2()
    if network == 'erdos':
        net = erdos(param)
    if network == 'random_digraph':
        net = random_digraph(param)
    if network == 'watts3':
        net = watts3(param)
    if network == 'watts5':
        net = watts5(param)
    return net

#-- Differential equation utilities --#

def random_lorenz_x0():
    """ Random initial condition for lorenz equations """
    return  20*(2*np.random.rand(3) - 1)

def rc_solve_ode(diff_eq_params):
    """ Wrapper for solving arbitrary ODEs"""
    solver = diff_eq_params.pop("solver")
    sol = solver(**diff_eq_params)
    diff_eq_params["solver"] = solver
    return sol

def how_long_accurate(u, pre, tol=1):
    """ Find the first i such that ||u_i - pre_i||_2 > tol """
    for i in range(u.shape[1]):
        dist = np.sum((u[:,i] - pre[:,i])**2)**.5
        if dist > tol:
            return i
    return u.shape[1]

#-- Main experiment --#

def results_dict(*args, **kwargs):
    """ Generate a dictionary for storing experiment results
    """
    ntrials, topology, topo_p, remove_p = args
    results =  {i: {'pred' : [],
                    'err' : [],
                    'adj' : None,
                    'net' : topology,
                    'topo_p' : topo_p,
                    'gamma' : kwargs['gamma'],
                    'sigma' : kwargs['sigma'],
                    'spect_rad"' : kwargs['spect_rad'],
                    'ridge_alpha' : kwargs['ridge_alpha'],
                    'remove_p' : remove_p
                    } for i in range(ntrials)}
    return results

def experiment(
    fname,
    topology,
    topo_p,
    res_params,
    diff_eq_params,
    ntrials=5,
    norbits=5,
    x0=random_lorenz_x0,
    remove_p=0
):
    """ Tests the reservoir computers generated by the given hyper parameters
        on 'norbits' different orbits

        Parameters
        ----------
        fname (str) : Name of the file where results will be saved
        topology (str) : Network topology in [barab1, barab2, erdos, random_digraph, watts3, watts5]
        topo_p (float) : Parameter accompanying the topology
        res_params (dict) : Dictionary of all parameters for the ResComp class
        diff_eq_params (dict) : Dictionary of all parameters for the rc_solve_ode function
        ntrials (int) : How many different reservoir computers to generate
        norbits (int) : How many orbits per reservoir computer
        x0 (function) : Generates an initial condition
        remove_p (float) : Percent of edges to remove from the network
    """
    # Make dictionary to store data
    results = results_dict(ntrials, topology, topo_p, remove_p, **res_params)
    i = 0
    while i < ntrials:
        adj = generate_adj(topology, topo_p)
        # Remove Edges
        if remove_p != 0:
            adj = remove_edges(adj, floor(remove_p*np.sum(adj != 0)))
        results[i]["adj"] = adj
        for j in range(norbits):
            # Initial condition
            diff_eq_params["x0"] = x0()
            train_t, test_t, u = rc_solve_ode(diff_eq_params)
            rc = ResComp(adj, **res_params)
            # Train network
            results[i]["err"].append(rc.fit(train_t, u))
            results[i]["pred"].append(how_long_accurate(u(test_t), rc.predict(test_t), tol=TOL))
        i += 1
        pickle.dump(results, open(fname,"wb"))
        print(f"Net complete-- \n\tNet: {topology} \n\tPercent {remove_p}")
